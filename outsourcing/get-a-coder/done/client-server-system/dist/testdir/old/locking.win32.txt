Run-Time Library Reference 	 
_sopen, _wsopen

Open a file for sharing.

int _sopen(
   const char *filename,
   int oflag,
   int shflag [,
   int pmode ] 
);
int _wsopen(
   const wchar_t *filename,
   int oflag,
   int shflag [,
   int pmode ] 
);

Parameters

filename
    Filename.
oflag
    Type of operations allowed.
shflag
    Type of sharing allowed.
pmode
    Permission setting.

Return Value

Each of these functions returns a file descriptor for the opened file. A return value of \u20131 indicates an error, in which case errno is set to one of the following values:

EACCES
    Given path is a directory, or file is read-only, but an open-for-writing operation was attempted.
EEXIST
    _O_CREAT and _O_EXCL flags were specified, but filename already exists.
EINVAL
    Invalid oflag or shflag argument.
EMFILE
    No more file descriptors available.
ENOENT
    File or path not found.

See _doserrno, errno, _sys_errlist, and _sys_nerr for more information on these, and other, return codes.
Remarks

The _sopen function opens the file specified by filename and prepares the file for shared reading or writing, as defined by oflag and shflag. _wsopen is a wide-character version of _sopen; the filename argument to _wsopen is a wide-character string. _wsopen and _sopen behave identically otherwise.

Generic-Text Routine Mappings
TCHAR.H routine 	_UNICODE & _MBCS not defined 	_MBCS defined 	_UNICODE defined
_tsopen 	_sopen 	_sopen 	_wsopen

The integer expression oflag is formed by combining one or more of the following manifest constants, defined in the file FCNTL.H. When two or more constants form the argument oflag, they are combined with the bitwise-OR operator ( | ).

_O_APPEND
    Repositions file pointer to end of file before every write operation.
_O_BINARY
    Opens file in binary (untranslated) mode. (See fopen for a description of binary mode.)
_O_CREAT
    Creates and opens new file for writing. Has no effect if file specified by filename exists. The pmode argument is required when _O_CREAT is specified.
_O_CREAT | _O_SHORT_LIVED
    Create file as temporary and if possible do not flush to disk. The pmode argument is required when _O_CREAT is specified.
_O_CREAT | _O_TEMPORARY
    Create file as temporary; file is deleted when last file descriptor is closed. The pmode argument is required when _O_CREAT is specified. 
_O_CREAT | _O_EXCL
    Returns error value if file specified by filename exists. Applies only when used with _O_CREAT.
_O_NOINHERIT
    Prevents creation of a shared file descriptor.
_O_RANDOM
    Specifies primarily random access from disk.
_O_RDONLY
    Opens file for reading only; cannot be specified with _O_RDWR or _O_WRONLY.
_O_RDWR
    Opens file for both reading and writing; cannot be specified with _O_RDONLY or _O_WRONLY.
_O_SEQUENTIAL
    Specifies primarily sequential access from disk
_O_TEXT
    Opens file in text (translated) mode. (For more information, see Text and Binary Mode File I/O and fopen.)
_O_TRUNC
    Opens file and truncates it to zero length; the file must have write permission. You cannot specify this flag with _O_RDONLY. _O_TRUNC used with _O_CREAT opens an existing file or creates a new file.

        Note   The _O_TRUNC flag destroys the contents of the specified file.

_O_WRONLY
    Opens file for writing only; cannot be specified with _O_RDONLY or _O_RDWR.

To specify the file access mode, you must specify either _O_RDONLY, _O_RDWR, or _O_WRONLY. There is no default value for the access mode.

The argument shflag is a constant expression consisting of one of the following manifest constants, defined in SHARE.H.

_SH_DENYRW
    Denies read and write access to file
_SH_DENYWR
    Denies write access to file
_SH_DENYRD
    Denies read access to file
_SH_DENYNO
    Permits read and write access

The pmode argument is required only when you specify _O_CREAT. If the file does not exist, pmode specifies the file's permission settings, which are set when the new file is closed the first time. Otherwise pmode is ignored. pmode is an integer expression that contains one or both of the manifest constants _S_IWRITE and _S_IREAD, defined in SYS\STAT.H. When both constants are given, they are combined with the bitwise-OR operator. The meaning of pmode is as follows:

_S_IWRITE
    Writing permitted
_S_IREAD
    Reading permitted
_S_IREAD | _S_IWRITE
    Reading and writing permitted

If write permission is not given, the file is read-only. Under Windows 98/Me and Windows NT/2000/XP, all files are readable; it is not possible to give write-only permission. Thus the modes _S_IWRITE and _S_IREAD | _S_IWRITE are equivalent.

_sopen applies the current file-permission mask to pmode before setting the permissions (see _umask).
Requirements
Routine 	Required header 	Optional headers 	Compatibility
_sopen 	<io.h> 	<fcntl.h>, <sys/types.h>, <sys/stat.h>, <share.h> 	Win 98, Win Me, Win NT, Win 2000, Win XP
_wsopen 	<io.h> or <wchar.h> 	<fcntl.h>, <sys/types.h>, <sys/stat.h>, <share.h> 	Win NT, Win 2000, Win XP

For additional compatibility information, see Compatibility in the Introduction.

Libraries

All versions of the C run-time libraries.
Example

See the example for _locking.


Example

// crt_locking.c
/* This program opens a file with sharing. It locks
 * some bytes before reading them, then unlocks them. Note that the
 * program works correctly only if the file exists.
 */

#include <io.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/locking.h>
#include <share.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>

int main( void )
{
   int  fh, numread;
   char buffer[40];

   /* Quit if can't open file or system doesn't 
    * support sharing. 
    */
   fh = _sopen( "crt_locking.txt", _O_RDWR, _SH_DENYNO, 
                 _S_IREAD | _S_IWRITE );
   if( fh == -1 )
      exit( 1 );

   /* Lock some bytes and read them. Then unlock. */
   if( _locking( fh, LK_NBLCK, 30L ) != -1 )
   {
      printf( "No one can change these bytes while I'm reading them\n" );
      numread = _read( fh, buffer, 30 );
      buffer[30] = '\0';
      printf( "%d bytes read: %.30s\n", numread, buffer );
      lseek( fh, 0L, SEEK_SET );
     _locking( fh, LK_UNLCK, 30L );
      printf( "Now I'm done. Do what you will with them\n" );
   }
   else
      perror( "Locking failed\n" );

   _close( fh );
}

Input: crt_locking.txt

The first thirty bytes of this file will be locked.

Output

No one can change these bytes while I'm reading them
30 bytes read: The first thirty bytes of this
Now I'm done. Do what you will with them
